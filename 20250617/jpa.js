/* JPA란? */
// 자바 진영의 ORM(Object Relational Mapping) 기술 표준으로 ORM 기술을 사용하기 위한 표준 인터페이스의 모음을 의미한다.
// Hibernate, EclipseLink 등의 구현체를 통해 사용된다.
// JPA는 영속성 컨텍스트를 통해 엔티티의 생명주기를 관리하며, 이를 통해 객체 상태를 자동으로 DB와 동기화할 수 있다.
// 필요 시에는 native SQL을 통해 직접 SQL을 작성하여 데이터베이스와 통신할 수도 있다.
// 또한 데이터베이스 종류에 따라 Dialect(방언)을 제공하여, DBMS에 맞는 SQL이 생성되도록 지원한다.

/* ORM이란? */
// ORM(Object Relational Mapping : 객체 관계 매핑)은 객체 지향 프로그래밍 언어의 객체와
// 관계형 데이터베이스의 테이블을 매핑하여 객체를 통해 데이터베이스 작업을 수행할 수 있도록 해주는 기술이다.
// 즉, 자바 객체와 DB 테이블을 1:1로 매핑하고, 자바 객체간의 관계를 토대로 SQL을 자동 생성 및 실행할 수 있도록 해주는 기술이다.
// 그 결과 SQL 작성과 JDBC API 사용을 줄이고 객체 중심의 프로그래밍을 가능하게 한다.

/* JPA 장점 */
// - 객체지향(Java)과 관계지향(RDBMS)이라는 서로 다른 패러다임 불일치를 해소해주며 SQL 중심이 아닌 객체지향 패러다임 중심의 개발이 가능하다.
// - 개발자가 직접 SQL을 따로 작성하지 않아도 SQL 문을 작성해주므로 생산성이 향상된다.
// - SQL을 수정할 필요가 없으므로 설정 및 필드가 변경되어도 SQL이 자동으로 수정되어 유지보수가 향상된다.
// - DB의 종류에 따라 SQL문에 다소 차이가 있는데 JPA가 제공하는 Dialect을 통해 개발자 대신 이를 판단하고 해당 DB에 맞게 SQL을 작성해준다.
// - 캐시를 활용한 성능 최적화로 인해 트랜잭션을 처리하는 시간이 굉장히 단축된다.

/* JPA 단점 */
// 너무 복잡한 SQL을 작성하기에는 적합하지 않다.
// JPA를 제대로 이해하지 못하고 작성 시 성능 저하가 발생할 수 있다.
// 객체지향 패러다임과 관계형 데이터베이스 패러다임에 대한 이해가 없는 상태로는 제대로 이해할 수 없다.
// 복잡한 동적 SQL같은 경우 순수 JPA만으로는 부족한 부분에 있어 추가 라이브러리를 활용해야 할 경우가 생길 수 있다.

/* 영속성 컨텍스트란? */
// 영속성 컨텍스트(Persistence Context)란 엔티티를 영구 저장(persist)하기 위해 JPA에서 사용하는 일종의 메모리 상의 저장공간이다. 
// 즉, 어플리케이션과 데이터베이스 사이에서 엔티티 객체를 보관하고 관리하는 가상의 데이터베이스 역할을 한다.
// 개발자가 entityManager.persist(엔티티) 메소드를 호출하면,
// 해당 엔티티는 영속성 컨텍스트에 저장되고 관리되며, 이후 데이터베이스와 동기화된다.
// 이 때, 동일한 트랜잭션 내에서 동일한 엔티티는 영속성 컨텍스트 내에서 1차캐시(Identity Map)를 통해 공유된다.
// 영속성 컨텍스트는 엔티티 매니저가 생성될 때 함께 만들어지며,
// 엔티티 매니저와 영속성 컨텍스트는 1:1 관계를 갖는다.
// 따라서 엔티티 매니저를 통해 영속성 컨텍스트에 접근하고 엔티티의 상태를 관리할 수 있다.

/* 엔티티(Entity)란? */
// JPA에서 엔티티는 데이터베이스 테이블과 매핑되는 자바 객체를 의미한다.
// JPA는 객체 지향 프로그래밍 방식으로 데이터베이스를 관리할 수 있도록 도와주며,
// 엔티티는 이러한 JPA를 통해 관리되는 핵심적인 객체이다.

/* EntityManager란? */
// 엔티티 매니저는 엔티티를 저장하는 메모리상의 데이터베이스이다. 엔티티 저장, 수정, 삭제, 조회 등 엔티티와 관련된 모든 일을 한다.
// 엔티티 매니저는 스레드 세이프 하지 않기 때문에 동시성 문제가 발생할 수 있어 스레드 간 공유하면 안된다.
// 그래서 Web의 경우 일반적으로 request scope와 일치 시킨다.

/* EntityManagerFactory의 역할이란? */
// 엔티티 매니저를 생성할 수 있는 기능을 제공하는 팩토리 클래스이다. 스레드 세이프 하기 때문에 여러 스레드가 동시에 접근해도 안전하므로
// 서로 다른 스레드 간 공유해서 재사용한다.
// 스레드 세이프 한 기능을 요청 스코프마다 생성하기에는 비용(시간, 메모리) 부담이 크기 때문에
// application 스코프아 동일한 싱글톤으로 생성해서 관리하게 된다.
// 따라서 데이터 베이스를 사용하는 어플리케이션 당 한 개의 엔티티 매니저 팩토리를 생성한다.

// ++) JPA와 MyBatis 둘 다 영속성 프레임워크의 기술인데 ORM이냐 SQL 매퍼냐에 따라 구분된다.
/* MyBatis와 JPA */
// MyBatis는 SQL Mapper로 SQL Mapping을 사용하는 영속성(DB 저장) 프레임워크이다.
// 개발자가 직접 SQL 코드를 작성하고 객체에 대해 매핑을 위한 설정을 모두 직접 처리해야 한다.
// 또한 수정이 이루어질 시 SQL뿐만 아니라 매핑 될 객체(비즈니스 로직)도 같이 수정해야 하는 번거로움이 있다.
// JPA와 마이바티스는 분류상 서로 다르다. JPA는 ORM 기술이고, MyBatis는 SQL Mapper의 한 종류이다.
// 어플리케이션이 고도화 되면 JPA를 구현하여 손이 많이 가는 것보다 MyBatis가 답이 될 수도 있다.
// (JPA가 무조건 좋은 것은 아니다. 다만 JPA는 추가 라이브러리를 활용하면 복잡한 SQL이나 동적 SQL에 있어 도움을 받을 수 있다.)