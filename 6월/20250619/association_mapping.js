/* Association Mapping */
// Association Mapping은 Entity 클래스 간의 관계를 매칭하는 것을 의미한다.
// 이를 통해 객체를 이용해 데이터 베이터의 테이블 간의 관계를 매핑할 수 있다.

/* 다중성에 의한 분류 */
// 연관 관계가 있는 객체 관계에서 실제로 연관을 가지는 객체의 수에 따라 분류된다.
// - N:1(ManyToOne) 연관 관계
//   : 다데ㅐ일 관계에서 사용된다. 
//     예를 들어 하나의 카테고리가 여러 개의 메뉴를 가질 수 있는 상황에서 메뉴 엔티티가 카테고리 엔티티를 참조하는 것이다.
//     이 때 메뉴 엔티티가 Many, 카테고리 엔티티가 One이 된다.
// - 1:N(OneToMany) 연관 관계
//   : 일대다 관계에서 사용된다.
//     예를 들어 하나의 카테고리는 여러 개의 메뉴를 가질 수 있는 상황에서 카테고리 엔티티가 메뉴 엔티티를 참조하는 것이다.
//     이 때 카테고리 엔티티가 One, 메뉴 엔티티가 Many이다.
// - 1:1(OneToOne) 연관 관계 
//   : 일대일 관계에서 사용된다.
// - N:N(ManyToMany) 연관 관계
//   : 다대다 관계에서 사용된다. 그렇지만 실질적으로 DB 설계 시 다대다 관계를 형성하지 않기에 잘 사용하지 않는다.

/* 방향에 따른 분류 */
// 테이블의 견관 관계는 외래 키를 이용하여 양방향 연관 관계의 특징을 가진다.
// 창조에 의한 객체의 연관 관계는 단방향이다.
// 객체간의 연관 관계를 양방향으로 만들고 싶을 경우 반대쪽에서도 필드를 추가해서 참조를 보관하면 된다.
// 하지만 엄밀히 말하면 이는 양방향 관계가 아니라 단방향 관계 2개로 볼 수 있다.

/* BiDirection */
// DB의 테이블은 FK 하나로 양방향 조회가 가능하지만 객체는 서로 다른 두 단방향 참조를 합쳐서 양방향이라고 한다.
// 따라서 두 개의 연관 관계 중 연관 관계의 주인을 정하고, 주인이 아닌 연관 곤계를 하나 더 추가하는 방식으로 작성하게 된다.
// 양방향 연관 관계는 항상 설정하는 것이 아니라 반대 방향으로도 접근하여 객체를 탐색해야하는 일이 많을 경우에만 사용한다.
// 양방향 연관 관계 시 연관 관계의 주인이라는 이름은 비즈니스 중요도를 배제하고 단순히 FK 관리자의 의미를 부여해야 한다.
// 즉, 연관 관계의 주인은 외래키를 가지고 있는 엔티티이다.
// 예를 들면 메뉴 엔티티는 카테고리 엔티티의 카테고리 코드를 FK로 참조하고 있다면 FK를 갖는 메뉴 엔티티가 연관 관계의 주인이 된다.

/* 지연 로딩과 즉시 로딩에 대해 설명하시오. */
// 즉시 로딩(Eager)이란 데이터를 조회할 때, 연관된 모든 객체의 데이터까지 한 번에 불러오는 것을 의미한다.
// ManyToOne 연관 관계일 경우에는 즉시 로딩이 기본값이며 필요에 의해 지연 로딩으로 변경하고자 할 때는
// fetch 옵션을 통해 FetchType.LAZY로 설정해주면 된다.
// ex) @ManyToOne(fetch = FetchType.LAZY)
// 즉시 로딩은 연관된 엔티티를 모두 가져온다는 장점이 있지만, 실무에서 엔티티 간의 관계가 복잡해질 수록 조인으로 인한 성능 저하를 피할 수 없고
// JPQL에서 N+1문제를 일으킨다. 
// 즉시 로딩은 불필요한 조인까지 포함해 처리하는 경우가 많기 때문에 지연 로딩의 사용을 권장하고 있다.
// 지연 로딩은 연관된 엔티티를 처음에는 조회하지 않고, 실제로 해당 엔티티가 필요한 시점에 조회하는 방식이다.
// OneToMany 연관 관계일 경우에 지연 로딩이 기본값이며, 필요에 의해 즉시 로딩으로 변경하고자 할 떈
// fetch 롭선을 통해 FetchType.EAGER로 설정하면 된다.
// ex) @OneToMany(fetch = FetchType.EAGER)
// 지연 로딩을 사용하려면 DB 트랜잭션 내에서 연관된 엔티티에 접근해야만 DB 조회가 일어난다.
// 지연 로딩은 필요한 시점에만 데이터를 로딩하기 때문에 성능 최적화이며, 
// 사용자가 실제로 해당 데이터를 사용할 때만 로딩하므로 데이터베이스 접근이 최적화된다.

/* 즉시 로딩 선택 이유 */
// 1. 객체 간의 관계를 활용하기 편리하다.
// : 즉시 로딩을 사용하면 객체를 조회할 때 연관된 모든 엔티티를 한 번에 조회하기 때문에 객체 간의 관계를 편히라게 활용할 수 있다.
//   모든 연관된 데이터가 이미 로딩되어 있으므로 어떤 객체를 사용할 때 별다른 DB 조회 없이 객체 그래프를 따라 이동할 수 있다.
// 2. 복잡한 조회를 단순화한다.
// : DB에서 조인을 사용한 복잡한 연관 관계를 해결할 필요없이, 즉시 로딩으로 모든 데이터를 한 번에 가져올 수 있다.

/* 지연 로딩 선택 이유 */
// 1. 성능 최적화
// : 즉시 로딩은 모든 연관된 데이터를 한 번에 가져오기 때문에, 필요하지 않은 데이터까지 불필요하게 로딩될 수 있다.
//   이는 성능 저하를 야기할 수 있는데 지연 로딩은 필요한 시점에만 데이터를 로딩하기 때문에 성능을 최적화할 수 있다.
// 2. 데이터 접근을 최적화한다.
// : 사용자가 실제로 해당 데이터를 사용할 때만 로딩하므로 데이터 베이스에 접근이 최적화된다. 따라서 시스템 전체적으로 데이터 로딩에 대한 부하가 분산된다.
// 3. 순환 참조 방지
// : 지연 로딩을 사용하면 객체 간의 연관 관계에서 순환 참조가 발생할 확률이 감소한다. 
//   객체를 조회할 때 실제로 필요한 데이터만 로딩되므로 무한한 순환 참조를 막을 수 있다.
// 4. 메모리 사용 최적화
// : 즉시 로딩은 연관된 모든 데이터를 로딩하기 때문에 메모리를 많이 사용할 수 있다.
//   하지만 지연 로딩은 필요한 데이터만 로딩하기 때문에 메모리 사용을 최적화할 수 있다.
