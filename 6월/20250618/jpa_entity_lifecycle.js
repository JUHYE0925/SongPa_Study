/* 영속성 컨텍스트에서의 Entity 생명주기 */
// 영속성 컨텍스트는 엔티티 매니저가 엔티티를 저장하는 공간으로 엔티티를 보관하고 관리한다.
// 엔티티 매니저가 생성될 때 하나의 영속성 컨텍스트가 만들어진다.
// 영속성 컨텍스트에서의 엔티티의 생명주기는 다음과 같다.
// 비영속(new/transient) : 엔티티가 영속성 컨텍스트와 전혀 관계가 없는 상태이다.
// 영속(managed) : 엔티티가 영속성 컨텍스트에 저장된 상태로 persist(), find() 등의 메소드를 사용한다. 
// 준영속(detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태로 detach(), clear(), close()를 사용한다. 
// 삭제(removed) : 엔티티가 영속성 컨텍스트에서 삭제된 상태로 remove()를 사용한다.
// 병합(merge) : 준영속 상태인 엔티티가 다시 영속상태로 변경된 상태를 말하며 merge()를 사용한다.

/* Entity 어노테이션 */
// @Entity
// : JPA에서 엔티티 클래스임을 명시하는 어노테이션이다.
//   해당 어노테이션이 붙은 클래스는 JPA에서 관리되는 엔티티이다.
// @Table
// : JPA에서 테이블을 명시하는 어노테이션이다.
//   해당 어노테이션을 사용하면 엔티티와 매핑할 테이블의 이름을 정할 수 있다.
// @Id
// : JPA에서 엔티티의 PK임을 명시하는 어노테이션이다.
//   이 어노테이션을 사용하면 엔티티 내에서 해당 필드를 PK로 사용할 수 있다.
// @Column
// : JPA에서 해당 필드가 테이블의 컬럼임을 명시하는 어노테이션이다.
//   이 어노테이션을 사용하면 엔티티 필드와 테이블 컬럼 간의 매핑을 정할 수 있다.
// @GeneratedValue
// : JPA에서 엔티티의 기본 키를 자동 생성할 때 사용하는 어노테이션이다.
//   해당 어노테이션을 사용하면 기본 키 생성 전략을 설정할 수 있고 IDENTITY를 사용하여 AUTO_INCREMENT를 설정할 수 있다.

/* 영속성 컨텍스트가 엔티티를 관리하는 원리 */
// 1차 캐시
// : 영속성 컨텍스트 내부에 Map으로 관리되는 캐시(key는 @id이며 매핑한 식별자이고, value는 엔티티 인스턴스이다.)이며
//   이 곳에 있는 엔티티는 캐시에서 바로 불러와서 조회 성능이 올라간다.
// 동일성 보장
// : 반복해서 호출 시 1차 캐시에 같은 엔티티 인스턴스가 있을 경우 영속성 컨텍스트에서 가져온다.
// 트랜잭션을 지원하는 쓰기 지연(transactional write-behind)
// : (엔티티 등록(INSERT)을 예로 들면) 엔티티 매니저는 트랜잭션을 commit하기 직전까지 DB에 저장(flush) 대신
//   쓰기 지연 SQL 저장소에 INSERT SQL을 차곡차곡 쌓게 되며 커밋 시 쿼리를 DB로 보내는데 이를 트랜잭션을 지원하는 쓰기 지연이라고 한다.
//   여기서 flush란 영속성 컨텍스트의 변경 내영을 DB에 반영하는 것이다. 하지만 commit된 상태는 아니기에 rollback을 사용하여 값을 되돌릴 수 있다.
// 변경 감지(dirty checking)
// : SQL에 의존적이지 않도록 엔티티의 데이터 변경을 감지하고 DB에 자동으로 반영하는 기능을 변경 감지라고 하낟.
//   영속성 컨텍스트에 보관할 때 최초 엔티티 상태를 복사해서 저장한 스냅샷과 이를 비교하여 감지한다.
//   영속 상태의 엔티티에만 적용되며 준영속이나 비영속은 해당되지 않는다.
// 변경 감지 정차(커밋 실행 시)
// 1) 엔티티와 스냅샷을 비교해서 변경된 엔티티를 찾는다.
// 2) 변경된 엔티티와 관련된 수정 쿼리를 생성해서 쓰기 지연 SQL 저장소에 보낸다.
// 3) 쓰기 지연 저장소의 SQL을 DB로 보낸다.
// 4) DB에서 트랜잭션을 커밋한다.