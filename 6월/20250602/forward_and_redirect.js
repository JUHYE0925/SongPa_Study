/* 데이터 전송 구조 */
// 브라우저가 서버에 요청을 보낼 때, 요청 정보는 HTTP 프로토콜에 따라 텍스트 기반 메세지로 전송됩니다.
// 이 메세지는 메소드(GET, POST 등), URL, 헤더, 바디 등의 정보가 포함됩니다.
// 톰캣과 같은 서블릿 컨테이너는 이 HTTP 요청 메세지를 파싱하여 HttpServletRequest 객체로 추상화하고,
// 이를 해당 서블릿의 service() 메소드에 전달합니다.
// 서블릿은 HttpServletRequest를 통해 요청 정보를 읽고, HttpServletResponse를 통해 클라이언트에 응답을 작성합니다.
// 이 응답 또한 HTTP 형식으로 전송되어 브라우저가 해석해 화면에 표시합니다.

/* forward 방식이란? */
// forward는 서블릿에서 클라이언트의 요청을 다른 자원(서블릿, JSP 등)으로 서버 내부에서 전달하는 방식이다.
// 클라이언트는 단 하나의 요청만 보내며, 요청과 응답은 서버 내부에서 전달되므로, URL은 변경되지 않는다.
// forward의 동작 과정은 다음과 같다.
// 1. 웹 브라우저가 servlet1에게 요청을 보낸다.
// 2. servlet1이 요청을 처리한 후 필요한 데이터를 HttpServletRequest에 저장한다.
// 3. servlet1는 RequestDispatcher()를 통해 servlet2로 요청(request와 response 둘 다)을 전달(forward) 한다.
// 4. servlet2는 전달받은 request와 response 객체를 이용해 요청을 처리하고, 결과를 클라이언트에 응답한다.
// 이 방식은 서버 내부에서만 이동하므로 빠르며, 주로 요청 처리 중 중간 작업을 다른 자원에 위임할 때 사용된다.
// forward의 특징으로는
// 클라이언트가 servlet1에 보낸 요청을 서버 내부에서 servlet2로 넘기는 구조이기 때문에 클라이언트가 그 사실을 알 수 없다.
// 그렇기 때문에 URL이 바뀌지 않으며 브라우저의 주소창에는 최초 요청 URL이 유지된다.

/* redirect 방식이란? */
// redirect는 클라이언트에게 새로운 요청을 다시 보내도록 지시하는 방식으로,
// 서버가 클라이언트에게 다른 URL로 이동하라는 응답을 보내는 방식이다.
// redirect의 동작 과정은 다음과 같다.
// 1. 클라이언트가 servlet1에 요청을 보낸다.
// 2. servlet1이 요청을 처리한 후, HttpServletResponse.sendRedirect("새 URL")을 호출한다.
// 3. 서버는 HTTP 응답에 302 상태 코드와 Location 헤더를 포함하여 클라이언트에게 전송한다.
// 4. 클라이언트는 응답을 받은 뒤, Location에 명시된 새 URL로 다시 요청을 보낸다.
// 5. 새로운 요청을 받은 servlet2는 응답을 처리하여 결과를 클라이언트에게 전달한다.
// redirect의 특징으로는
// 브라우저의 주소창에 URL이 변경되며, 서버에서 클라이언트로 요청 흐름이 전환된다.
// 기존의 HttpServletRequest 객체는 공유되지 않기 때문에, 데이터 전달 시에는 Session이나 Cookie에 담아서 전송한다.
// 주로 로그인 후 메인 페이지 이동, 게시글 작성 후 목록 페이지로 이동 등의 경우에 사용된다.

/* forward와 redirect의 차이점을 설명하시오. */
// forward는 같은 요청 내에서 서버 내부 자원 간 처리를 위임할 때 사용하고,
// redirect는 클라이언트가 새로운 요청을 보내도록 할 때 사용하며,
// URL 변경과 요청 횟수에서 차이가 난다.

/* Cookie와 Session을 사용하는 이유 */
// HTTP 프로토콜의 특성이자 약점을 보완하기 위해서 쿠키 또는 세션을 사용한다.
// 기본적으로 HTTP 프로토콜의 환경은 Connectionless(무연결), stateless(무상태)한 특성을 가지기 때문에
// 서버는 클라이언트가 누구인지 매번 확인해야 한다. 이 특성을 보완하기 위해서 쿠키와 세션을 사용하게 된다.
// 우선 connectionless와 stateless에 대해서 설명하겠다.
// connectionless는 
// 클라이언트가 요청을 한 후 응답을 받으면 그 연결을 끊어버리는 특성이다.
// HTTP는 먼저 클라이언트가 request를 서버에 보내면, 서버는 클라이언트에게 요청을 처리 후 요청에 맞는 response를 보내고 접속을 끊는 특징이 있다.
// stateless는
// 통신이 끝나면 상태를 유지하지 않는 특징이다.
// 연결을 끊는 순간 클라이언트와 서버의 통신이 끝나며 상태 정보는 더이상 유지하지 않는다.
// 쿠키와 세션은 이 두 가지의 특징을 보완하기 위해 사용된다.
// 예를 들어 쿠키와 세션을 사용하지 않을 경우
// 온라인으로 주문을 하려고 로그인을 하였음에도 불구하고, 페이지를 이동할 때 마다 로그인을 계속 해야 하는 경우가 생긴다.
// 이 때 쿠키와 세션을 사용하게 되면, 한 번 로그인을 하면 만료 시간까지 사용자의 정보가 서버나 로컬에 저장되어 있기 때문에 그 사용자에 대한 인증을 유지하게 된다.

/* cookie란? */
// 쿠키는 클라이언트(브라우저)에 저장되는 key-value 형태의 데이터로, 
// 서버가 클라이언트의 상태 정보를 저장하거나 추적할 때 사용됩니다.
// 쿠키는 서버가 응답 시 Set-Cookie 헤더에 포함시켜 브라우저에 전달하며, 
// 브라우저는 이후 동일한 도메인에 요청할 때 해당 쿠키를 자동으로 함께 전송합니다.
// 쿠키에는 유효 시간을 설정할 수 있으며, 만료 시간을 지정하면 브라우저를 닫아도 해당 시간까지 쿠키는 유지됩니다.
// 하지만 공용 PC 등에서 민감한 정보를 쿠키에 저장할 경우 보안에 취약할 수 있다는 단점이 있습니다.
// 즉, 쿠키는 클라이언트 측 저장소이기 때문에, 보안이 중요한 정보는 세션이나 서버 DB쪽에서 저장하는 것이 일반적이다.
//
// 쿠키의 기본 동작 과정은 다음과 같습니다:
// 1. 클라이언트가 서버에 요청을 보냅니다.
// 2. 서버는 `new Cookie("key", "value")`를 통해 쿠키 객체를 생성하고, 만료 시간을 초 단위로 설정합니다.
// 3. 생성된 쿠키는 응답 헤더(Set-Cookie)에 포함되어 클라이언트에 전달됩니다.
// 4. 클라이언트는 쿠키를 저장하고, 이후 같은 서버로 요청할 때 쿠키를 요청 헤더(Cookie)에 포함시켜 전송합니다.
// 5. 서버는 클라이언트가 보낸 쿠키를 읽어 이전 상태를 유지하거나, 필요 시 쿠키 값을 수정해 다시 응답에 포함시킵니다.
//
// 쿠키는 주로 자동 로그인, 장바구니, 최근 본 상품 등의 기능에 사용됩니다.

/* session이란? */
// 세션은 클라이언트의 상태 정보를 서버 측에서 관리하는 방식으로, 
// 쿠키보다 보안성이 높은 사용자 인증 방식입니다.
// 서버는 클라이언트마다 별도의 세션을 가지며 클라이언트를 식별하기 위해 고유한 세션 ID를 발급한다.
// 이 ID는 쿠키를 통해 클라이언트 측에 저장되어 이후 서버에 연결 요청을 할 때마다 함께 전송하여 서버가 어떤 세션을 사용할 지 판단할 수 있게 한다.
// 이 때 서버와 클라이언트는 세션ID를 공유할 방법으로
// 서버는 전달받은 세션 ID를 기반으로 해당 클라이언트의 세션 정보를 조회하고, 필요한 데이터를 유지하거나 처리합니다.
//
// 세션의 동작 방식은 다음과 같습니다:
// 1. 클라이언트가 서버에 최초 요청을 보냅니다.
// 2. 서버는 고유한 세션 ID를 생성하고, 응답에 Set-Cookie를 통해 클라이언트에 전달합니다.
// 3. 클라이언트는 이후 요청마다 해당 세션 ID를 쿠키에 담아 자동으로 전송합니다.
// 4. 서버는 세션 ID를 확인하고, 서버 메모리에 저장된 사용자 상태 정보를 바탕으로 요청을 처리합니다.
//
// 세션은 서버에서 데이터를 관리하기 때문에 쿠키보다 보안성이 높지만, 사용자 수가 많을 경우 서버 메모리를 많이 사용하게 되어 성능 저하가 발생할 수 있습니다.
// 일반적으로 로그인 상태 유지, 사용자 인증과 같은 보안이 중요한 작업에서 사용됩니다.

/* 쿠키와 세션의 차이 */
// 쿠키와 세션은 비슷한 역할을 하며, 동작원리도 비슷합니다. 그 이유는 세션도 결국 쿠키를 사용하기 때문입니다.
// 가장 큰 차이점은 사용자의 정보가 저장되는 위치입니다. 때문에 쿠키는 서버의 자원을 전혀 사용하지 않으며, 세션은 서버의 자원을 사용합니다.
// 보안 면에서 세션이 더 우수하며, 요청 속도는 쿠키가 세션보다 더 빠릅니다. 그 이유는 세션은 서버의 처리가 필요하기 때문입니다.
// 보안 : 쿠키는 클라이언트 로컬에 저장되기 때문에 변질되거나 request에서 스니핑 당할 우려가 있어서 보안에 취약하지만 세션은 쿠키를 이용해서 sessionid 만 저장하고 그것으로 구분해서 서버에서 처리하기 때문에 비교적 보안성이 좋습니다.
// 라이프 사이클 : 쿠키도 만료시간이 있지만 파일로 저장되기 때문에 브라우저를 종료해도 계속해서 정보가 남아 있을 수 있다. 또한 만료기간을 넉넉하게 잡아두면 쿠키삭제를 할 때 까지 유지될 수도 있습니다.
// 반면에 세션도 만료시간을 정할 수 있지만 브라우저가 종료되면 만료시간에 상관없이 삭제됩니다. 예를 들어, 크롬에서 다른 탭을 사용해도 세션을 공유됩니다. 다른 브라우저를 사용하게 되면 다른 세션을 사용할 수 있습니다.
// 속도 : 쿠키에 정보가 있기 때문에 서버에 요청시 속도가 빠르고 세션은 정보가 서버에 있기 때문에 처리가 요구되어 비교적 느린 속도를 가집니다.


/* 세션이 보안에 더 유리한데 쿠키를 사용하는 이유 */
// 세션은 서버의 자원을 사용하기 때문에 무분별하게 세션을 만들다 보면 서버의 메모리가 감당할 수 없어질 수 있고
// 그 결과 속도가 느려질 수 있기 때문에 쿠키가 유리한 경우가 있다.

/* filter란? */
// Filter는 요청과 응답을 가로채 공통 작업을 처리하는 서블릿의 전/후처리 컴포넌트이다.
// javax.servlet.Filter 인터페이스를 상속받아 구현하는 클래스로
// 클라이언트의 요청과 서버의 응답 사이에서 데이터를 가로채어 전처리 또는 후처리하는 기능을 담당한다.
// 요청에 대란 인코딩 설정, 인증 처리, 로그 기록, 응답 압축 등 공통 처리를 담당하는 데 주로 사용된다.
// 필터의 동작 방식은 다음과 같다.
// 1. 서버가 시작될 때 필터 객체가 생성되고, init() 메소드가 호출된다.
// 2. 클라이언트가 요청을 보내면, 필터의 doFilter() 메소드가 먼저 실행된다.
// 3. doFilter() 에서는 요청을 가로채어 필요한 전처리를 수행한 후, 다음 필터나 서블릿으로 요청을 전달한다.
// 4. 서블릿에서 요청을 처리하고 응답을 생성하면, 다시 doFilter()로 돌아와 후처리를 수행할 수 있다.
// 5. 최종적으로 응답이 클라이언트에게 전달된다.
// 6. 서버가 종료되면 destroy() 메소드가 호출되어 필터가 소멸된다.
// 
// 필터는 요청 및 응답을 가로채는 구조이기 때문에, 필수적인 보안/로깅/공통 정책 적용에 매우 유용하게 활용된다.

/* JSP란? */
// JSP(Java Server Pages)는 HTML 코드 내에 Java 코드를 삽입하여 동적인 웹페이지를 생성할 수 있는 서버 사이드 기술이다.
// JSP 파일은 최초 요청 시 서블릿(.java)으로 변환되고, 그 후 .class 파일로 컴파일되어 실행된다.
// 이렇게 변환된 서블릿은 웹 어플리케이션 서버(Tomcat 등)에서 동작하며, 클라이언트의 요청에 따라 동적인 데이터를 처리하고 결과를 HTML로 응답한다.
// JSP는 표현이 간단하고, 화면 출력에 특화되어 있어 뷰(View) 역할을 수행하며, MVC 패턴에서 주로 view 계층에 해당한다.
// 최근에는 JSP보다 템플릿(Thymeleaf)이 더 많이 쓰이지만, JSP는 서블릿 기반 동적 웹 페이지 생성 원리를 이해하는 데 좋은 기반이 된다.

/* JSP 스크림트 요소 종류 */
// 스크립트 요소는 JSP 페이지 안에서 자바 코드를 작성할 수 있게 해주는 문법 요소를 의미한다.
// 이들은 JSP가 서블릿으로 변환될 때 어떤 위치에 어떤 식으로 코드가 들어가는지를 결정하므로, JSP 구조를 이해하는 데 매우 중요하다.
// Scriptlet : <% 자바 코드 %> 
// : JSP 페이지 안에서 일반 자바 코드를 삽입할 때 사용한다. 반복문, 조건문 등 간단한 로직 처리가 가능하다.
//   서블릿의 service() 메소드 내부로 들어간다.
// Expression : <%= 값 또는 변수 %>
// : 결과를 바로 HTML에 출력할 때 사용한다. 이미 요소에 ;이 포함되어 있기에 세미콜론 없이 단일 표현식으로만 사용 가능하다.
//   out.print()로 변환된다.
// Declaration : <%! 변수 또는 메소드 선언 %>
// : 클래스 수준의 멤버 변수나 메소드를 선언할 때 사용한다.
//   서블릿 클래스의 필드나 메소드로 변환된다.
// Directice(지시어) : <!@ 지시어 속성="값" %>
// : JSP 페이지에 대한 설정 정보를 정의한다. 예를 들면 인코딩, import, errorPage 설정 등이 있다.
//   ex) <%@ page contentType="text/html;charset=UTF-8" %>
// 주석 : <%-- 주석 내용 --%> 
// : JSP에서 컴파일되지 않는 서버 주석이다. HTML 주석과는 다르다.
// Action Tag(액션 태그) : <jsp:태그 ... />
// : 자바 코드 대신 JSP 표준 태그로 기능을 수행하는 요소이다.
// ex) <jsp:include page="header.jsp"/>
//
// 예시 코드
// <%@ page language="java" contentType="text/html;charset=UTF-8" %>
// <html>
// <body>
//<%
//     int count = 5; // 스크립틀릿
// %>
// <p>카운트 값: <%= count %></p> <!-- 표현식 -->
// <%! 
//     private int square(int x) {  // 선언부
//         return x * x;
//     }
// %>
// <p>4의 제곱: <%= square(4) %></p>
// <%-- 이건 JSP 주석입니다. --%>
// </body>
// </html>
//
// JSP에는 자바 코드를 삽입할 수 있는 여러 스크립트 요소가 있으며, 각각의 용도에 따라 서블릿 변환 시 위치가 달라진다.
// 특히 표현식은 출력 용도, 스크립틀릿은 로직, 선언부는 클래스 멤버 정의에 사용된다. 
