/* 오버플로우와 언더플로우 */
// 오버플로우와 언더플로우는 선언된 변수의 자료형의 범위를 벗어난 값을 할당할 경우 발생한다.
// 오버플로우는 선언된 자료형보다 큰 값을 할당할 경우 최대 범위에서 반전을 일으켜 오히려 최소 범위의 값을 출력한다.
// 언더플로우는 오버플로우와 반대로 최소 범위보다 더 작은 값을 할당할 때 최소 범위에서 반전을 일으켜 최대 범위 값을 출력한다.
// 이러한 문제를 해결하기 위한 방법으로는 형변환이 있다.

/* ㄴ> 오버플로우/언더플로우가 발생하면 예외가 발생하는가? */
// 아니오. 예외는 발생하지 않고 값이 반전됩니다.

/* ㄴ> 자바에서 오버플로우를 방지할 수 있는 방법에는 무엇이 있는가? */
// Math.addExact(), BigInteger 사용

/* ㄴ> 실제 백엔드 시스템에서 오버플로우가 문제가 되는 경우는? */
// DB에 정수 값을 저장할 때 overflow 발생 시 데이터 손실 가능

/* 형변환 */
// 형변환이란 데이터의 타입을 변환시키는 것으로 자바에서는 같은 데이터 타입끼리의 연산만 가능하기에
// 다른 데이터 타입끼리의 연산을 위해서 형변환이 필요하다.
// 형변환에는 자동 형변환과 강제 형변환이 있다.
// 자동 형변환은 컴파일러가 자동으로 데이터를 형변환 해주는 경우로 주로 작은 자료형의 값을 큰 자료형에 담을 때,
// 정수를 실수형 데이터타입에 담을 때, 문자형을 int 형에 담을 때 일어난다.
// 반대로 강제 형변환은 자동 형변환이 적용되지 않은 경우 강제 형변환이 필요하다.
// 즉, 큰 자료형의 값을 작은 자료형에 담을 때, 실수를 정수로 변경할 때, 문자형을 int 미만 크기의 변수에 저장할 때 강제 형변환을 한다.
// 강제 형변환은 바꾸혀는 자료형을 캐스트 연산자(소괄호())를 이용하여 형변환을 한다.
// 또한 논리형은 자동 형변환이과 강제 형변환 규칙 모두에서 제외된다.

/* ㄴ> 자바에서 int와 Integer는 어떻게 다르고, 형변환과 관련된 이슈는 무엇인가? */
// int와 Integer는 모두 자바에서 정부를 나타내는 자료형이지만 근본적인 차이점과 사용방법에서 차이가 있다.
// int는 자바에서 기본 자료형(primitive type)이며, Integer는 자바의 객체(Object)를 기반으로 하는 래퍼 클래스(wrapper class)이다.
// int는 기본 자료형으로 별도의 메모리 할당이나 객체 생성 과정이 필요하지 않으며, 단순히 값을 저장하고 연산하는 용도로 빠르게 사용할 수 있다.
// 또한 int는 기본적으로 메모리에 값을 바로 저장하기 때문에 객체처럼 null로 초기화가 불가능하다.
// int는 단순히 4byte의 메모리를 사용하며 변수에 값을 저장한다. 기본 자료형으로 처리되기 때문에 할당이나 참조 없이 빠르게 접근 가능하여 메모리와 성능에서 높은 효율성을 가진다.
// Integer는 int를 객체로 다루기 위해 제공되는 wrapper class이다. 
// 기본 자료형인 int를 감싸고 객체로 변환해 다양한 추가 기능을 제공한다.
// 특히 Integer는 int 값과 관련된 유틸리티 메소드를 제공하여 숫자 변환, 문자열 변환, 비교, 상수 값 제공 등의 다양한 작업을 가능하게 한다.
// 또한 Integer는 객체 타입으로 null 값을 가질 수 있고 메모리와 성능 측면에서는 int에 비해 비효율적이다.
// 즉 Integer는 객체이므로 객체 셍성 시 추가 메모리가 필요하다. 객체를 생성할 때 메모리에는 객체 자체의 정보 외에도 참조가 추가된다. 
// Integer는 객체이기 때문에 heap 메모리에 저장되고 참조(referance)를 통해 접근하지 때문에 int에 비해 성능이 떨어질 수 있다.
// 또한 Integer는 불변 객체(immutable)로 한 번 생성된 객체는 수정할 수 없고 새로운 값을 할당할 때 마다 새로운 객체를 생성해야하는데 이 과정이 자주 반복될 경우 성능에 부정적인 영향을 미친다.

/* ㄴ> double을 int로 강제 형변환했을 때 어떤 일이 벌어지는가? */
// 실수형을 정수형으로 강제 형변환할 땐 소수점 이하가 절삭되는 데이터 손실이 일어납니다.

/* ㄴ> 실무에서 형변환이 위험한 이유는 무엇이라고 생각하는가? */
// 데이터 손실이 일어나며 예외가 발생하고 그로 인해 예상치 못한 결과가 발생합니다.

/* 지역변수와 매개변수 */
// 지역변수는 선언한 메소드 블럭 내에서만 사용 가능하다.
// 다른 메소드 간 서로 공유해야하는 값이 존재하는 경우 메소드 호출 시 사용하는 괄호를 이용하여 값을 전달할 수 있다.
// 이 때 전달하는 값을 전달인자라고 부르고, 메소드 선언부 괄호 안에 전달 인자를 받기 위해 선언하는 변수를 매개변수라고 부른다.

/* 지역변수와 인스턴스 변수의 차이를 설명하시오 */
// 우선 지역변수와 인스턴스 변수는 자바와 같은 객체 지향 프로그래밍 언어에서 사용하는 변수 중 하나호 메모리 공간과 접근 범위에 따라 차이가 있다.
// 지역 변수는 메소드 내에서만 사용 가능한 변수이며, 인스턴스 변수는 객체 생성 시 각 객체마다 독립적으로 할당되는 변수이다.
// 지역변수는 메소드 호출 시 stack에 할당되며 메소드가 종료되면 메모리에서도 제거된다.
// 또한 메소드 내에서만 접근 가능하며, 메소드 외부에서는 접근 불가능하다.
// 생명주기로는 메소드 호출 시 생성되어 메소드 종료 시 소멸되며 사용하기 전에 반드시 초기화해야 한다. 그렇지 않을 경우 컴파일 에러가 발생한다.
// 인스턴스 변수의 경우에는 객체가 생성될 때 heap 메모리에 할당되며 객체가 소멸될 때 메모리에서도 제거된다.
// 클래스 내에서 정의된 메소드 및 블록에서 접근 가능하며, 객체가 생성될 때 생성되어 객체가 소멸할 때 제거된다.
// 초기화하지 않으면 각 데이터 타입에 해당하는 기본값으로 초기화된다.
// 또한 각 객체마다 별도의 메모리 공간에 할당되므로, 각 객체는 서로 다른 값을 가질 수 있다.
// 즉 지역변수는 메소드 내부에서 임시적으로 값을 저장하고 사용하는데 사용되며, 인스턴스 변수는 각 객페의 속성을 나타내는 데 사용된다.
// 특히 객체 지향 프로그래밍에서 인스턴스 변수는 객체의 상태를 나태내며, 객체마다 고유한 값을 가질 수 있다는 특징을 갖는다. 
