/* List, ArrayList, LinkedList 설명 */
// ArrayList와 LinkedList는 Collection Frame Work의 List 인터페이스를 상속 받아 구현한 클래스이다.
// ArrayList와 LinkedList 둘 다 순서 있는 데이터 집합으로 뎅디터의 중복 저장을 허용한다는 공통점을 가지고 있다.
// ArrayList는 배열의 크기 변경 불가 및 요소의 추가/삭제 등의 기능이 복잡하다는 단점을 보완하기 위해 만들어졌다.
// ArrayList는 크기 변경, 요소 추가 및 생성, 정렬의 기능을 미리 메소드로 구현하여 제공하지만
// 자동적으로 수행되는 것이지 배열보다 속도가 빠른 것은 아니다.
// LinkedList는 ArrayList기 배열을 이용해서 발생할 수 있는 성능적인 단점(속도)을 보완하고자 만들어졌으며 내부는 이중 연결 리스트로 구현되어있다.
// LinkedList는 이전 요소와 다음 요소의 주소값 모두 포함하는 자료구조로 해당 요소에 빠르게 접근할 수 있다는 장점을 가지고 있다.
// 
// ------------- 수정안 ---------------
// // ArrayList와 LinkedList는 Collection Framework의 List 인터페이스를 구현한 클래스이다.
// 두 클래스 모두 순서가 있는 데이터 집합이며, 데이터의 중복 저장을 허용한다는 공통점이 있다.
// ArrayList는 내부적으로 배열을 사용하며, 요소에 인덱스로 빠르게 접근할 수 있다는 장점이 있다.
// 그러나 배열의 크기를 변경할 수 없기 때문에, 요소 추가나 삭제 시 성능 저하가 발생할 수 있다.
// 반면 LinkedList는 이중 연결 리스트 구조로, 요소 간의 참조(링크)를 통해 연결되어 있다.
// 요소의 삽입 및 삭제가 자주 일어나는 경우에는 LinkedList가 ArrayList보다 효율적이다.
// 하지만 인덱스를 통한 임의 접근은 느리기 때문에, 사용 목적에 따라 적절히 선택해야 한다.


/* 단순 연결 리스트, 이중 연결 리스트 */
// 단순 연결 리스트와 이중 연결 리스트 모두 저장한 요소가 순서를 유지하지 않고 저장되지만 
// 이러한 요소들 사이를 링크로 연결하여 구성하며 마치 연결된 리스트 형태인 것 처럼 만든 자료구조이다.
// 요소의 저장과 삭제 시 다음 요소를 가리키는 참조 링크(주소)만 변경하면 되기 때문에 
// 요소의 저장과 삭제가 빈번히 일어나는 경우 ArrayList보다 성능 면에서는 우수하다.
// 하지만 단순 연결 리스트는 다음 요소만 링크하기 대문에 이전 요소로 접근하기는 어렵지만
// 이중 연결 리스트는 다음 요소와 이전 요소 모두를 링크하기 때문에 이전 요소와 다음 요소로 접근하기 쉬우며 속도가 빠르다는 장점이 있다.
//
// ------------- 수정안 ---------------
// // 단순 연결 리스트(Singly Linked List)와 이중 연결 리스트(Doubly Linked List)는
// 노드들이 포인터(링크)를 통해 서로 연결된 구조의 자료구조이다.
// 단순 연결 리스트는 각 노드가 다음 노드를 가리키는 참조만 가지고 있어, 앞에서부터 순차적으로 접근해야 한다.
// 반면 이중 연결 리스트는 각 노드가 이전 노드와 다음 노드에 대한 참조를 모두 가지고 있어 양방향으로 이동이 가능하다.
// 이로 인해 요소 삽입 및 삭제가 자주 발생하는 상황에서는 배열 기반 구조보다 효율적이다.


/* Collection Frame Work(List, Set, Map 등) 설명 */
// 컬렉션 프레임 워크란 데이터를 효율적으로 저장하는 자료구조와
// 데이터를 처리하는 알고리즘을 미리 구현해 놓은 클래스이다.
// 컬렉션 프레임 워크는 크게 3가지 인터페이스(List 인터페이스, Set 인터페이스, Map 인터페이스)로 나뉘며 이 중 한가지를 상속받아 구현해놓았다.
// List 인터페이스는 순서 있는 데이터의 집합으로 데이터의 중복 저장을 허용한다.
// Set 인터페이스는 순서가 없는 데이터 집합으로 데이터의 중복을 허용하지 않는다.
// Map 인터페이스는 키와 값의 한 쌍으로 일어지는 데이터 집합이며
// 키를 Set 방식으로 관리하게 때문에 데이터의 순서를 관리하지 않고 중복된 키를 허용하지 않는다.
// 하지만 value는 중복된 값을 저장할 수 있다.
//
// ------------- 수정안 ---------------
// 컬렉션 프레임워크는 데이터를 효율적으로 저장하고 처리하기 위한 자료구조와 알고리즘을 구현해 놓은 자바의 표준 라이브러리이다.
// 주요 인터페이스로는 List, Set, Map이 있으며, 각 인터페이스는 특징에 따라 다양한 구현 클래스를 제공한다.
// - List: 순서가 있는 데이터 집합이며, 중복 저장을 허용한다. (예: ArrayList, LinkedList)
// - Set: 순서가 없으며, 중복을 허용하지 않는 집합 구조이다. (예: HashSet, TreeSet)
// - Map: 키-값 쌍으로 데이터를 저장하며, 키는 중복될 수 없지만 값은 중복이 가능하다. (예: HashMap, TreeMap)
// Map의 키는 Set으로 관리되기 때문에 기본적으로 순서를 보장하지 않지만, LinkedHashMap은 입력 순서를 유지한다.


/* 오류와 예외 차이 */
// 자바에서는 문법에 맞게 작성하여 컴파일 에러가 발생하지 않아도
// 런타임 시 예상치 못한 오류가 발생할 수도 있다.
// 이렇게 컴퓨터 프로그램이 동작하는 도중에 예상치 못한 사태가 발생하여 실행 중인 프로그램이 비정상적으로 종료되는 것을 오류와 예외로 구분할 수 있다.
// 오류는 시스템 상에서 프로그램에 심각한 문제가 발생하여 실행 중인 프로그램이 종료되는 것을 말하는데
// 이러한 오류는 개발자가 미리 예측하여 처리하는 것이 불가능하다.
// 반대로 예외의 경우에는 실행 중인 프로그램이 비정상적으로 종료되는 것은 비슷하지만
// 발생할 수 있는 상황을 미리 예측하고 처리할 수 있다.
// 그렇기에 개발자는 이러한 예외에 대해 예외 처리를 통해 예외 상황을 적절히 처리하여 코드의 흐름을 컨트롤할 수 있다.
//
// ------------- 수정안 ---------------
// 자바에서 프로그램 실행 중 발생할 수 있는 문제 상황은 오류(Error)와 예외(Exception)로 구분된다.
// 오류(Error)는 주로 JVM의 내부 문제나 시스템 자원 부족 등으로 인해 발생하며, 개발자가 직접 처리할 수 없는 심각한 문제이다.
// 예외(Exception)는 프로그램 실행 중 발생할 수 있는 예측 가능한 문제로, 개발자가 이를 처리할 수 있다.
// 예외는 다시 검사 예외(Checked Exception)와 비검사 예외(Unchecked Exception)로 나뉜다.
// 예외 처리를 통해 프로그램의 비정상 종료를 방지하고, 안정적인 흐름을 유지할 수 있다.
