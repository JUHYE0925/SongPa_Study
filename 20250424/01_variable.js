/* JAVA & JavaScript 공통 개념 */

/* 변수란 무엇인가요? */
// 변수는 값을 저장할 수 있는 메모리의 공간을 의미한다.
// 또한 이름에서 유추할 수 있듯이 변수는 변하는 값/변하는 수이기도 하다.

/* var, let, const의 차이는? */
// var, let, const는 자바스크립트에서 변수를 선언할 때 사용하는 키워드이다.
// var는 ES6의 이전에 사용되던 변수 선언 방식식이며, let과 const는 ES6에서 새롭게 도입된 변수 선언 키워드이다.
// var는 함수 스코프를 가지며 함수 내에서만 지역 변수로 작동하지만, 블록 내무에서 선언해도 해당 블록 외부에서 접근이 가능하다.
// let과 const는 블록 스코프를 가지며, 이는 let과 const로 선언된 변수가 중괄호({})로 둘러싸인 블록 내에서만 유효하여 블록 외부에서 접근이 불가하다.
// 또한 호이스팅에서도 차이가 있다.
// var로 선언된 변수는 호이스팅 되어 함수나 전역 스코프의 최상단으로 끌어올려지지만
// let이나 const로 선언된 변수는 호이스팅은 되지만, 선언 전에 접근할 수 없는 '일시적 사각지대'를 가진다다.
// 즉, var로 선언된 변수는 호이스팅 시 변수 선언과 동시에 undefined로 초기화되어어 선언 전에도 접근할 수 있다.
// 반면 let이나 const로 선언된 변수는 호이스팅이 되지만 초기화되지 않는다. 
// 즉, let과 const도 호이스팅이 되지만 일시적 사각지대에 있기 때문에 선언 전에 접근하려고 하면
// 참조에러(ReferenceError)가 발생한다.
// 추가적으로 const는 상수로 사용되어 재할당이 불가하지만 객체나 배열의 경우 내부 값은 변경할 수 있다.
// let은 재할당은 가능하지만 블록 스코프를 가지므로 보다 안전하고 예측 가능한 코드 작성을 도와준다.

/* Java의 기본형 타입과 참조형 타입의 차이 */
// 자바에서 자료형은 크게 기본형과 참조형 타입으로 나뉘며 이는 데이터가 메모리에 저장되는 방식과 처리 방식에 차이를 둔다.
// 기본형은 계산을 위해 실제 값을 저장하는 타입이며며, 참조형은 객체의 주소를 저장하는데 null 또는 객체의 주소를 갖는다.
// 기본형은 크게 정수형(byte, short, int, long), 실수형(float, double), 문자형(char), 논리형(boolean)로 총 8가지로 나뉜다.
// 모두 소문자로 시작하며 비객체 타입으로 null 값을 가질 수 없으며 각 타입별로 기본값이 존재한다.
// 또한 메모리의 stack 영역에 저장되며, 선언 시점에 메모리가 할당되고 실제 데이터 값을 저장한다.
// 참조형은 배열, 클래스, 인터페이스, 열거형 등 기본형을 제외한 모든 타입을 의미한다.
// 참조형은 기본형과 달리 실제 값이 저장되지 않고, 객체가가 저장된 공간의 주소를 저장한다.
// 즉, 실제 값은 heap에 저장되며 그 주소값을 갖는 변수는 stack에 저장된다.
// 또한 참조형 변수는 null로 초기화할 수 있으며 이는 어떤 객체도 참조하지 않음을 의미한다.

/* Java와 JavaScript에서 변수의 스코프(scope)는 어떻게 동작하나요? */
// Java는 정적 타입 언어로, 블록 스코프 기반이다.
// Java에서의 스코프는 클래스 스코프, 메소드 스코프, 블록 스코프, 파라미터 스코프로 나뉜다.
// 클래스 스코프는 클래스 전체에서 접근 가능하지만 접근 제한자(public, private 등)에 따라 범위가 달라진다.
// 메소드 스코프는 메소드 내부에서 선언된 변수로 해당 메소드 내에서만 유효하다.
// 블록 스코프는 if문, for문 등 중괄호({}) 안에서 선언된 변수는 블록 안에서만 유효하다.
// 파라미터 스코프는 메소드의 매개변수는 해당 메소드 안에서만 사용 가능하다.
// Java의 변수 스코프는 컴파일 타임에 결졍되며 중괄호를 기준으로 철저하게 구분된다. 또한 변수의 생명주기는 스코프가 끝날 때까지이다.
// JavaScript에서의 변수의 스코프는 JavaScript는 동적 타입 언어이며 과거에는 var 중심의 함수 스코프만 존재했지만, ES6부터는 let과 const로 블록 스코프를 지원한다.
// JavaScript에서는 var, let, const와 같은 선언된 키워드에 따라 스코프가 다르게 작동한다.
// var는 함수 스코프를 가지며, 블록({})을 무시하고 함수 내부에서만 유효하다.
// let과 const는 블록 스코프를 가지며 선언된 블록 안에서만 유효하다.
// let과 const는 호이스팅 되긴 하지만 일시적 사각지대가 존재하며 선언 전에 접근하려고 하면 ReferenceError가 발생한다.
// 또한 JavaScript에서는 클로저(closure)를 통해 내부 함수가 외부 함수의 스코프에 접근할 수 있는 것이 특징이다.

/* ++) 클로저(closure)란? */
// 클로저란 함수가 선언될 때의 외부 스코프를 기억하고 나중에 그 함수가 실행될 때에도 그 외부 변수에 접근할 수 있는 기능을 말한다.
// 쉽게 말하면 함수가 자기 바깥쪽 스코프의 변수들을 기억하고 있는 상태이다.
// 그래서 함수가 외부 함수보다 오래 살아남아도 그 변수들을 계속 참조할 수 있다.
function outer() {
  let count = 0; // 외부 함수의 변수

  return function inner() {
    count++;
    console.log(count);
  };
}
  
const counter = outer();  // outer 실행 → inner를 반환
counter(); // 1
counter(); // 2
counter(); // 3
  // 위의 예제의 경우 inner() 함수는 outer() 함수 안에서 정의되었고,
  // outer() 가 이미 실행을 마쳐서 사라졌음에도 불구하고,
  // count에 계속 접근할 수 있는데 이게 바로 클로저이다.
  // 클로저가 중요한 이유는 외부 변수에 계속 접근하면서 데이터를 저장할 수 있도록 상태 유지를 하며
  // 외부에서 직접 접근할 수 없는 private한 값을 만들 수 있는 정보 은닉이 가능하며
  // 콜백, 이벤트 핸들러, 비동기 처리 등에서 자주 활용된다.

/* ============================================================ */

/* JavaScript 관련 질문 */

/* 호이스팅(Hoisting)이란 무엇인가요? var 변수는 어떻게 작동하나요? */
// 자바스크립트에서 호이스팅이란, 자바스크립트 엔진이 코드를 실행하기 이전에 변수와 함수의 선언을 메모리 상단으로 끌어올리는 동작을 말한다.
// 즉, 선언이 코드의 아래쪽에 있어도, 자바스크립트가 실행되기 전에 먼저 인식하게 된다.
// var로 선언한 변수의 경우 호이스팅 시점에 undefined로 변수를 초기화되며, 변수 선언이 코드의 위로 끌어올려진 것 처럼 동작한다.
// 반면 let과 const로 선언한 변수의 경우에는 호이스팅은 되지만 초기화되지 않으며 선언 전 접근 시 참조 오류(ReferenceError)가 발생한다.

/* JavaScript에서 undefined와 null의 차이는 무엇인가요? */
// undefined와 null 모두 자바스크립트의 원시타입이지만 의미적으로 분명한 차이가 있다.
// 자바스크립트에서 undefined는 변수가 선언은 되었지만 값이 할당되지 않은 상태를 나타내며, 자바스크립트 엔진이 자동으로 부여하는 기본값이다.
// 반면 null은 개발자가 명시적으로 '값이 없음'을 표현할 때 사용하는 값이다.
// 즉, undefined는 '값이 아직 없음', null은 '의도적으로 값이 없음'이라는 의미를 가지며 이 점에서 두 값은 다르게 사요오디어야한다.
let a;
console.log(a); // undefined - 변수는 선언되었지만 값이 없음
let b = null;
console.log(b); // null - 값이 명시적으로 없음
// a는 선언만 되었고 값을 할당하지 않았기 때문에 자바스크립트 엔진이 자동으로 undefined를 부여한한다.
// b는 의도적으로 "아직 값이 정해지지 않았다"는 의미로 null을 할당한 것이며, 이는 명확한 의도를 나타낸다.

/* 타입 변환(Type Coercion)이란 무엇인가요? */
// 타입 변환이란 자바스크립트에서 서로 다른 타입 간의 연산이 발생할 때, 자바스크립트 엔진이 자동으로 타입을 변환해주는 과정을 말한다.
// 예를 들어 숫자와 문자열을 더하려고 하면 숫자를 문자열로 바꾸어 문자열 결합을 할 수 있게 수행한다.
// 타입 변환은 암시적 타입 변환과 명시적 타입 변환 두 가지가 있다.
// 타입 변환은 편리하지만 예기치 못한 결과를 초래할 수 있기 때문에, 명시적 변환을 사용하는 것이 안정적이다.
// 특히 조건문에서 falsy/truthy한 값의 판단 기준도 타입 변환의 일환으로 이해할 수 있다.

/* 동적 타이핑이란 무엇인가요? JavaScript는 어떤 타입 시스템을 쓰나요? */
// 자바스크립트는 동적 타입 언어인데 동적 타입 언어란 변수의 타입 지정 없이 값이 할당되는 과정에서 값의 타입에 의해 자동으로 타입이 결졍되는 것을 말한다.
// 따라서 같은 변수에 여러개의 타입을 선언하여도 문제가 없다.
let text = 'hello';
console.log(`value: ${text}, type: ${typeof text}`); //결과 : value: hello, type: string
text = 1;
console.log(`value: ${text}, type: ${typeof text}`); //결과 : value: 1, type: number
text = '7' + 2;
console.log(`value: ${text}, type: ${typeof text}`); //결과 : value: 72, type: string
text = '8' / '2';
console.log(`value: ${text}, type: ${typeof text}`); //결과 : value: 4, type: number
// 하지만 주의해야할 점이 있다. text라는 이름으로 선언된 변수를 확인하고 당연히 그 속에 값의 타입이 String이라고 생각하겠지만
// 위에서 말했듯이 유연한 자바스크립트는 여러개의 변수를 설정하고 바꾸고 할 수 있기 때문에 아래와 같은 코드로 인해 문제가 발생하는 경우도 있다.
let text2 = 'hello';
console.log(text.chartAt(0)); //결과 : h
text2 = '8' / '2';
console.log(text.chartAt(0)); //결과 : 런타임에러 ..
// 도중에 타입이 숫자로 바뀌게 되어버린 text의 charAt(0)은 에러가 날 수 밖에 없다.
// 이와 같이 자바스크립트는 런타임에서 타입이 정해지기 때문에 런타임 에러가 발생하는 현상이 많아진다.
// 이러한 타입의 문제 때문에 '타입스크립트'가 나오게 되었다.

/* ============================================================ */

/* Java 관련 질문(변수 범위 내) */

/* Java의 기본 자료형을 모두 말해보세요. */
// Java의 기본 자료형에는 총 8가지가 있다.
// 숫자는 정수를 다루는 자료형과 실수를 다루는 자료형으로 나뉘며 
// 정수를 다루는 자료형에는 byte, short, int, long이 있고 
// 각각 1byte, 2byte, 4byte, 8byte의 크기의 값을 담을 수 있으며 int가 대표 자료형이다..
// 실수를 다루는 자료형에는 float과 double이 있으며 각각 4byte, 8byte 크기이며 대표 자료형은 double이다.
// 문자를 다루는 자료형에는 char형으로 2byte이며 나머지로는 논리값을 다루는 boolean형으로 1byte 크기의 값을 담을 수 있다.

/* 정수형 변수와 실수형 변수의 차이는 무엇인가요? */
// 정수형 변수로는 정수의 값만 취급하는 변수로 byte, short, int, long 자료형 타입과 함께 사용된다.
// 실수형 변수로는 실수의 값만 취급하년 변수로 float. double 자료형 타입과 함께 쓰인다.

/* final 키워드는 변수 선언에 어떤 영향을 주나요? */
// final 키워드는 변수, 메소드, 클래스에 사용될 수 있으며 변수에 사용될 경우 상수를 의미하며 선언된 대상의 변경을 금지한다.
// 메소드에 사용될 경우에는 오버라이딩을 금지하며, 클래스에 사용될 경우에는 상속을 금지한다.
// 즉 final 키워드는 불변성을 보장하고 안정적인 코드를 작성하는데 도움을 준다.

/* 자바에서 변수는 메모리에 어떻게 저장되나요? */
// 자바에서 변수는 기본적으로 stack과 heap 메모리에 저장됩니다.
// 기본형 타입변수는 stack메모리에 값 자체가 저장되고,
// 참조형 타입 변수는 stack에는 heap에 있는 객체의 주소가 저장되며, new로 생성된 모든 객체의 실제 객체는 heap 메모리에 저장됩니다.
// stack은 메소드 호출 시 생성되며 빠르게 할당되고 메소드 종료 시 자동으로 해제되지만
// heap은 상대적으로 느리지만, 객체가 오래 유지되는데 사용됩니다.
// 자바에서는 가비지 컬렉션(GC)을 통해 더 이상 참조되지 않는 객체를 자동으로 제거합니다.

/* 클래스 멤버 변수(static)와 인스턴스 변수의 차이는? */
// 자바에서 변수는 선언된 위치에 따라서 크게 4종류로 나뉘며 클래스 변수, 인스턴스 변수, 지역변수, 매개변수로 나뉜다.
// 클래스 변수와 인스턴스 변수는 클래스 영역에서 선언된다는 공통점이 있다.
// 클래스 변수는 클래스 영역에서 타입 앞에 static이 붙는 변수이며 객체를 공유하는 변수로서 여러 객체에서 공통으로 사용하고 싶을 때 정의한다.
// 인스턴스 변수는 클래스 영역에서 static이 아닌 변수로 개별적인 저장 공간으로 객체/인스턴스마다 다른 값을 저장할 수 있다.
// 또한 인스턴스 변수는 객체/인스턴스 생성만 하고 참조 변수가 없는 경우에는 가비지 컬렉터에 의해서 자동적으로 제거된다.
// ++) 그 외에 지역 변수와 매개변수는 둘 다 메소드 영역에 선언되는 변수이다.
// 지역 변수의 경우 메소드 내에서 선언되고 메소드 수행이 끝나면 소멸되는 변수이다.
// 또한 초깃값을 지정한 후에 사용할 수 있다.
// 매개변수는 메소드 호출 시 '전달하는 값'을 가지고 있는 인수로서 지역변수처럼 선언된 곳부터 메소드의 수행이 끝날 때까지 유효하다.
// ++) 또한 각각의 생성시기가 다른데 클래스 변수는 클래스가 메모리에 올라갔을 때 생성되며
// 인스턴스 변수는 인스턴스가 생성되었을 때, 지역변수와 매개변수는 위치하고 있는 메소드가 호출 및 수행되었을 때 생성된다.

/* static과 final에 대해 설명하시오. */
// static과 final 키워드는 자바같은 객체 지향 프로그래밍을 할 때 매우 중요한 역할을 합니다.
// static 키워드는 주로 클래스 변수나 메소드에 사용되어 클래스 로드 시에 메모리에 할당되고, 프로그램 종료 시까지 유지됩니다.
// 이는 클래스의 인스턴스 간에 공유되는 속성이나 메소드를 정의할 때 유용합니다.
// final의 경우에는 변수, 메소드, 클래스에 사용될 수 있습니다. 변수에 선언될 경우에는 상수로서 변수의 값의 변경을 금지하고,
// 메소드에 사용될 경우 오버라이딩을 금지하며, 클래스에 사용될 경우에는 상속을 금지합니다.
// 즉, final은 불변성을 보장하고 안정적인 코드를 작성하는데 도움을 줍니다.
// 이러한 static과 final은 모두 자바 프로그래밍에서 코드의 안전성과 재사용성을 높이는데 기여합니다.
// 하지만 static의 경우에는 모든 인스턴스에서 공유되어 하나의 인스턴스에서 값이 변경되면
// 모든 인스턴스에 영향을 미치게 되며, final의 경우에는 변수의 변경이 불가능하여 코드의 실행 과정에서의 변수 값의 안정성을 보장할 수 없다는 문제가 있습니다.
// 참고) https://f-lab.kr/insight/understanding-java-static-final?gad_source=1&gad_source=1&gbraid=0AAAAACGgUFcQZfrOFwaaKPRC7d19lveH-&gclid=CjwKCAjwwqfABhBcEiwAZJjC3rL3JwuQ5SsEKRJbX17j8smL5mxHZh0W0dapk73LR3yjqYSDQkREEhoCzxEQAvD_BwE

/* ============================================================ */

/* ++) 번외: 개념 기반 질문 */

/* 컴파일러 언어와 인터프리터 언어의 차이는? */
// 컴파일러 언어는 사람이 이해하기 쉽도록 작성된 프로그래밍 언어인 Java와 같은 고급 언어로 작성된 소스 코드를 컴퓨터 내부에서 바로 처리 가능한 프로그래밍 언어인 저급 언어로 번역하는 프로그램을 가리킨다.
// 컴파일러 언어는 컴파일러를 통해 컴파일 타임에 전체 소스 코드를 한 번에 기계어로 변환 후 실행 파일을 만든다.
// 컴파일러 언어는 컴파일 단계와 실행 단계가 각각 분리되어 있으며, 컴파일은 단 한 번만 수행한다.
// 실행은 실행 파일을 실행시킴으로써 할 수 있으며, 실행 시에는 컴파일 과정을 거치지 않고 실행만 하면 되므로 코드 실행 속도가 빠르다.
// 단 프로젝트의 규모가 클 경우 컴파일 시간이 오래 걸릴 수 있다는 단점이 있다.
// 컴파일러 언어로는 C, C++, C#, Java 등이 있다.
// 인터프리터는 프로그래밍 언어의 소스 코드를 바로 실행하는 컴퓨터 프로그램을 말한다.
// 인터프리터 언어는 소스 코드를 한 번에 기계어로 변환하는 컴파일러와 달리, 컴파일 하지 않고 소스 코드를 한 줄씩 읽어들여 실행한다.
// 컴파일 하는 과정이 없기 때문에 컴파일 하는 시간은 소요되지 않으나, 인터프리터 언어는 실행 파일을 별도로 생성하지 않기 때문에 실행할 때 마다 인터프리트 과정이 반복 수행되어 실행 속도가 느리다는 단점이 있다.
// 인터프리터 언어로는 Python, JavaScript, Ruby 등이 있다.

/* Java와 JavaScript는 이름이 비슷한데 어떤 차이가 있나요? */
// Java와 JavaScript는 이름은 비슷하지만 완전히 다른 프로그래밍 언어이다.
// 타입 측면에서 보면 Java는 정적 타입 언어이며 JS는 동적 타입 언어이다.
// 사용 목적 측면에서는 Java는 주로 백엔드 개발, 서버 애플리케이션 개발 등에 사용되지만
// JS는 웹 페이지의 동적인 요소 구현, 프론트엔드 개발 등에 사용된다.
// 실행 환경 측면에서는 Java는 JVM(자바 가상 머신)에서 실행되지만 JS는 웹 브라우저에서 실행된다.
// 문법 측면으로는 Java는 클래스, 인터페이스, 추상 클래스 등 객체 지향 개념을 사용하며, JS는 프로토타입 기반 객체 지향을 사용한다.
// 성능 측면에서는 Java는 컴파일 언어로 JS보다 일반적으로 성능이 좋다.
// 또한 운영체제 측면에서는 Java는 운영체제 독립적인 특징을 가지고 있어, 다양한 운영체제에서 사용할 수 있다.
// 하지만 JS는 브라우저 종속적인 특징을 가지고 있어, 브라우저마다 동작 방식이 다를 수 있다.
// 요약하자면 Java는 객체 지향 프로그래밍 언어로, 다양한 애플리케이션 개발에 사용되며 
// JS는 스크립트 언어로, 웹 페이지의 동적인 요소 구현에 주로 사용된다.