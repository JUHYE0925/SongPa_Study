/* 객체 지향 프로그래밍이란? */
// 객체 지향 프로그래밍(OOP)은 프로그램을 구성할 때 데이터와 기능을 하나의 단위인 '객체'로 묶어서, 
// 객체 간의 상호작용을 통해 전체 로직을 구성하는 프로그래밍 방식입니다.
// 현실 세계의 사물이나 개념을 추상화하여, 상태(속성)와 행위(메소드)를 가지는 객체로 모델링하고, 
// 이 객체들이 유기적으로 상호작용하며 동작하도록 설계합니다.
// 객체는 현실 세계를 닮았지만 무생물이나 개념같은 존재도 객체로 정의할 수 있으며,
// 스스로의 상태를 제어하고 동작할 수 있는 주체로 간주한다는 점에서 차이가 있습니다.
// 이는 객체가 자율적인 행위의 주체로 행동한다는 점에서 의인화된 모델링이라고 볼 수 있습니다.

/* ㄴ> 객체 간의 상호작용에 대해 설명하시오. */
// 객체와 객체 간의 상호작용은 메세지 전달(메소드 호출)을 통해 이루어진다.
// 한 객체가 다른 객체에게 특정 기능을 요청하는 방식으로, 이 때 요청을 보내는 쪽을 송신자, 받는 쪽을 수신자라고 한다.
// 수신자는 전달 받은 메세지에 따라 어떤 동작을 할지 스스로 결정하며 이를 처리하는 방법을 메소드(method)로 구현한다.
// 이렇게 객체 간의 메세지를 수신하여 응답하는 상호작용을 설계하는 것이 객체지향 설계에서의 핵심입니다.
// 따라서 객체 설계 시에는 필드(데이터)보다 어떤 메세지를 주고 받고, 어떤 책임을 수행할 것인지(행위 중심)를 기준으로 추상화하는 것이 중요하다.

/* ㄴ> 객체 지향 프로그램밍의 장점과 단점 */
// 객체지향프로그래밍은 현실 세계를 모델링하여 소프트웨어를 구성하는 방식으로 여러가지 장점과 단점이 있습니다.
// 장점으로는
// 상속을 통해 기존 코드를 재사용할 수 있어 중복을 줄일 수 있는 코드 재사용성이 높습니다.
// 클래스 단위로 독립적인 개발이 가능해 팀 단위의 작업에 적합하며 유지보수에도 용이하므로 생선성이 향상됩니다.
// 캡슐화를 통해 객체 내부의 구현을 숨기고 외부와의 결합도를 낮춰 로직 변경 시 다른 부분에 적은 영향을 미치기 때문에 유지보수에 유용합니다.
// 마지막으로 역할과 책임이 분리되기 때문에 구조적인 시스템 설계와 협업이 수월하여 대형 프로젝트에 적합합니다.
// 단점으로는
// 현실 세계를 컴퓨터로 모델링하는 과정이 복잡하고 객체 간의 관계를 잘 정의해야하기 때문에 초기 설계에 많은 시간과 노력이 필요합니다.
// 또한 요구사항 분석과 클래스 설계에 많은 시간이 소요되어 소규모 프로젝트에는 오히려 비효율적이며 개발 시간이 느릴 수 있습니다.
// 마지막으로 모든 요소를 객체로 다루기 때문에 추가적인 메모리와 구조가 필요합니다. 즉 절차지향언어에 비해 실행 속도가 느리고 메모리 사용량이 많습니다.

/* ㄴ> 객체 또는 클래스는 무엇인가? */
// 클래스는 객체를 생성하기 위한 설계도 또는 틀이다. 클래스 안에는 객체가 가질 수 있는 속성(변수)과 행위(메소드)를 정의한다.
// 객체는는 이 클래스를 기반으로 실제 메모리에 생성된 실체(인스턴스)를 말한다.
// 즉, 클래스를 바탕으로 만들어진 실제로 사용 가능한 데이터 단위를 말한다.
// 정리하면 클래스는 설계도, 객체는 그 설계도를 바탕으로 만들어진 실제 제품이라고 할 수 있다.
// 또한한 클래스는 사용자가 서로 다른 타입의 데이터와 메소드를 하나의 구조로 정의할 수 있게 해주므로, 사용자 정의 자료형으로 분류된다.

/* 캡슐화란? */
// 캡슐화는 객체의 데이터(필드)에 대한 직접 접근을 제한하고, 메소드를 통해 간접적으로 접근하도록 만드는 기법이다.
// 주로 필드에 private으로 선언하여 직접 접근을 막고, public 메소드를 통해 간접적으로 값을 설정하거나 조회하게 한다.
// 이를 통해 외부에서 객체 내부의 구조를 직접 변경할 수 없기 때문에 결합도를 낮추고 유지 보수를 용이하게 할 수 있다.
// 또한 메소드 내부에서의 값의 유효성을 검증하는 로직을 추가할 수 있어 잘못된 데이터를 입력받는 것을 방지할 수 있다.
// 캡슐화를 지키지 않으면, 잘못된 값이 필드에 직접 할당될 수도 있고, 필드 변경 시 사용하는 모든 코드에 영향을 줘 유지보수가 어려워질 수 있다.

/* 접근제한자란? */
// 접근 제한자는 클래스, 필드, 메소드 등에 대한 접근 범위를 제어하기 위해 사용하는 키워드입니다.
// 객체 지향 설계에서 불필요한 접근을 제한하고, 데이터 보호와 모듈화를 위해 사용된다.
// 접근 제한자는 총 4가지로 public, protected, default, private가 있다.
// public은 모든 패키지(모든 클래스)에서 접근 가능하며, protected는 동일 패키지 또는 상속관계에 있는 클래스에서 접근 가능하다.
// default는 동일 패키지에서만 접근 가능하며 보통 접근제한자를 명시하지 않았을 때에 해당한다.
// private는 해당 클래스 내부에서만 접근 가능하다.
// 특히 클래스 선언 시에는 public과 default만 사용 가능하며, 클래스의 멤버(필드, 메소드)에는 네 가지 모두 사용 가능하다.
// 적절한 접근 제한자 설정은 객체 지향 설계의 핵심 원칙인 정보 은닉을 가능하게 한다.

/* 추상화란? - 정리 및 요약 */
// 추상화란 복잡한 시스템이나 객체로부터 핵심적인 속성과 동작만 추려내는 과정입니다.
// 공통적인 특징을 중심으로 모델링하여, 불필요한 세부 사항은 감추고 필요한 정보만 외부에 노출합니다.
// 추상화는 크게 2가지로 나뉩니다.
// 데이터 추상화는 공통된 특성을 중심으로 여러 객체를 일반화하는 것입니다.
// 예를 들면 삼각형, 사각형, 원이라는 객체가 있을 때 이 객체들의 공통 특징인 도형으로 묶어 이름을 붙이는 것을 데이터 추상화라고 한다.
// 제어 추상화는 객체의 내부 로직을 숨기고, 외부에는 메소드로만 기능을 제공하는 것입니다.
// 사용자는 내부 구현을 몰라도 메소드 호출만으로 기능을 사용할 수 있습니다.
// 추상화를 잘 활용하면 코드의 재사용성과 확장성이 높아지고, 상속 구조를 통해 공통 기능을 효율적으로 관리할 수 있습니다.

/* 추상화란? - 좀 더 자세한 정리 */
// 추상화란 복잡한 자료, 모듈, 시스템 등으로부터 핵심적인 개념 또는 기능을 간추려내는 것을 말한다.
// 즉, 유연성을 확보하기 위해 구체적인 사물들간의 공통적인 부분만 추출하고 공통적이지 않은 부분은 제거하는 것을 의미한다.
// 추상화는 데이터 추상화와 제어 추상화가 있다.
// 제어 추상화는 어떤 클래스의 메소드를 사용하는 사용자에게 해당 메소드의 작동 방식과 같은 내부 로직을 숨기는 것을 말한다.
// 이는 보다 프로그래밍을 빠르게 설계하고 구현하기 위해 사용된다. 
// 즉, 어떤 클래스의 메소드를 사용할 때 해당 메소드가 어떤 로직으로 구현되어 있는지를 알 필요 없이 메소드를 사용하는 것을 말하는데
// 구체적이지 않고 추상적으로 메소드 동작을 가늠해 결과값만 받고 끝낸다는 점에서 추상화 기능을 이용한다고 볼 수 있다.
// 데이터 추상화는 대상을 간단한 개념으로 일반화하는 과정을 말한다.
// 예를 들면 삼각형, 사각형, 원이라는 객체가 있을 때 이 객체들을 하나로 묶을 때 객체들의 공통 특징인 도형으로 묶어 이름을 붙이는 것을 데이터 추상화라고 한다.
// 이처럼 추상화를 하면 할 수록 객체의 디테일은 사라지고 공통된 특징만 남게 된다.
// 또한 이렇게 추상화한 상위 요소부터 각 요소에 맞는 기능들을 정의할 수 있으며, 하위 요소는 상위 요소가 가진 내용들을 가질 있도록 상속 관계를 설정하여 이어준다.
// 이렇게 공통된 기능을 상위 요소에서 미리 구현하면 하위 요소의 경우 하위 요소만의 고유 기능 위주로 개발할 수 있고 이런 추상화 구조 분리는 개발을 보다 빠르게 해준다.
// 즉, 공통 기능을 미리 개발해두면, 기능 상속을 통해 빠르게 구조를 확장할 수 있기때문이다.

/* 행위 중심으로의 추상화와 데이터 중심으로의 추상화에 대해 설명하시오 */
//
//
//
// https://prodo-developer.tistory.com/57

/* 상속 */
// 상속은 기존 클래스(부모 클래스)의 필드와 메소드를 새로운 클래스(자식 클래스)가 물려받아 
// 재사용할 수 있게 해주는 객체지향의 핵심 개념 중 하나입니다.
// 자식 클래스는 부모 클래스의 기능을 그대로 사용할 수 있을 뿐 아니라, 필요 시 일부 기능만 오버라이딩(재정의)하여 변경할 수 있습니다.
// 이를 통해 중복된 코드를 줄일 수 있으며, 코드의 재사용성과 유지보수성을 높이는 데 효과적입니다.
// 상속은 또한 객체 간의 계층 구조를 만들어 구조적인 설계가 가능하도록 하며
// Java에서는 다중 상속은 지원하지 않고 단일 상속만 지원되지만, 인터페이스를 통해 다형성을 유연하게게 구현할 수 있습니다.

/* 다형성 */
// 다형성은 하나의 인터페이스, 메소드, 객체가 여러 형태로 동작할 수 있는 객체지향의 중요한 특성입니다.
// 같은 이름의 메소드나 객체가 상황에 따라 다른 동작을 수행하는 것을 의미합니다.
// 다형성에는 대표적으로 오버라이딩과 오버로딩이 있습니다.
// 오버라이딩은 부모 클래스의 메소드를 자식 클래스에서 동일한 시그니처로 재정의하는 것을 말하며 
// 이는 런타임 시 어떤 메소드가 실행될지 결정되므로 동적 바인딩에 해당합니다.
// 오버로딩은 하나의 클래스 내에서 같은 이름의 메소드를 매개변수의 타입 또는 갯수로 구분하여 여러 개 정의하는 것을 의미합니다.
// 오버로딩은 컴파일 타임에 결정되므로 정적 바인딩에 해당합니다.
// 다형성은 특히 인터페이스나 추상 클래스와 함께 사용될 때 더 강력하게 작동하며, 
// 유연하고 확장 가능한 코드를 작성에 큰 도움이 됩니다.
// 또한 부모 타입의 참조 변수로 자식 객체를 참조할 수 있는 '업캐스팅'도 다형성의 대표적인 활용 예시입니다.

/* 업캐스팅과 다운캐스팅 */
//
//
//
// https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EC%97%85%EC%BA%90%EC%8A%A4%ED%8C%85-%EB%8B%A4%EC%9A%B4%EC%BA%90%EC%8A%A4%ED%8C%85-%ED%95%9C%EB%B0%A9-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0