/* 다형성(polymorphism) */
// 다형성은 객체 지향 프로그래밍의 3대 특징인 캡슐화, 상속, 다형성 중 하나로
// 다형성은 하나의 인스턴스가 여러 가지 타입을 가질 수 있는 것을 의미한다.
// 그렇기 때문에 하나의 타입으로 여러 타입의 인스턴스를 처리할 수 있고,
// 하나의 메소드 호출을 통해 객체별로 각기 다른 방법으로 메소드에 응답할 수 있다.
// 다형성은 객체 지향 프로그래밍의 꽃이라고 불리울 정도로 활용도가 높고 장점 또한 많다.

/* 다형성의 장점 */
// 1. 여러 타입의 객체를 하나의 타입으로 관리할 수 있어 유지보수성과 생산성이 증가한다.
// 2. 상속을 기반으로 한 기술이기 때문에 상속 관계에 있는 모든 객체는 동일한 메세지를 수신할 수 있다.
//    이렇게 동일한 메세지를 수신받을 때 객체별로 각기 다르게 처리할 수 있다는 장점을 가진다.
//    즉, 한 번의 호출로 여러 가지 동작을 수행할 수 있다는 장점인데 이러한 측면에서 오버로딩을 다형성으로 보기도 한다.
// 3. 확장성이 좋은 코드를 작성할 수 있다.
// 4. 결합도를 낮춰서 유지보수성을 증가시킬 수 있다.

/* 동적바인딩 */
// 동적바인딩이란 컴파일 당시에는 해당 타입의 메소드와 연결되어 있다가 런타임 시 
// 실제 해당 인스턴스와 맵핑된 메소드(오버라이딩 한 메소드)로 바인딩이 바뀌어 동작하는 것을 의미한다.
// 동적 바인딩은 반드시 상속 관계여야 하며 부모클래스로부터 오버라이딩한 메소드를 호출해야만 성립 가능하다.
//
// ex)
// Parent p = new child();
// p.methodA();
//
// 위와 같은 경우 자식 클래스의 인스턴스를 부모 타입으로 생성하였을 때
// methodA()를 호출하는 구문을 보면 컴파일 당시 methodA()는 부모 타입의 methodA()에 바인딩 되어 있다가
// 런타임 시 자식 클래스의 methodA()로 바인딩이 바뀌어 자식 클래스의 methodA()가 호출되는 것을 동적 바인딩이라고 한다. 

/* 클래스 형변환과 up-casting/down-casting */
// 자바에서 클래스 형변환이란, 상속 관계에 있는 클래스들 사이에서 타입을 변환하는 것을 말한다.
// 클래스 형변환은 크게 up-casting과 down-casting으로 나눌 수 있다.
// up-casting은 
// 자식 객체를 부모 타입으로 참조하는 것으로, 묵시적으로 형변환이 이루어진다.
// 이 경우 참조된 변수는 부모 타입이기 때문에, 부모 클래스에 정의된 멤버들만 접근 가능하다.
// 하지만 오버라이딩된 메소드가 있을 경우 실제로는 자식 클래스의 메소드가 실행된다.
// 이는 자바의 다형성과 관련된 동적 바인딩에 의해 동작되기 때문이다.
// down-casting은
// 부모 타입으로 선언된 참조 변수를 자식 타입으로 형변환 하는 것을 말하며 명시적으로 형변환을 해줘야한다.
// 단 이 경우 참조된 변수가 실제로 참조하고 있는 객체가 자식 타입일 경우에만 형변환이 가능하며,
// 그렇지 않을 경우에는 'ClassCastException' 이 발생할 수 있다.
// 이를 방지하기 위해 instanceof 연산자와 함께 사용하여 타입을 확인한 후 형변환을 수행하는 것이 안전하다.

/* ㄴ 왜 형변환을 사용하는가? */
// 자바에서 클래스 형변환은 주로 상속 관계에서 다형성을 활용하기 위해 사용된다.
// up-casting을 통해 자식 클래스를 부모 타입 하나로 통일하여 처리할 수 있어,
// 코드의 유연성과 재사용성이 증가한다.
// 예를 들어 다양한 자식 객체를 하나의 배열에 담아 처리할 수 있다.
// 또한 down-casting을 통해 부모 타입의 참조 변수를 통해 자식 객체의 고유한 기능에 접근할 때 사용할 수 있다.
// 다만 안전한 형변환을 위해 instanceof 연산자를 사용하는 것이 좋다.
// 결국 클래스 형변환은 자바의 다형성 구현과 함께 유연하고 확장 가능한 객체 지향 설계를 가능하게 하기 위해 사용된다.

/* ㄴ 형변환이 다형성과 어떤 관계인가? */
// 자바에서 다형성은 하나의 타입(보통 부모 클래스 또는 인터페이스)으로 여러 자식 객체를 처리할 수 있는 특성을 말한다.
// 이러한 다형성을 구현하기 위해 up-casting을 사용하면,
// 자식 객체를 부모 타입으로 참조할 수 있게 되어 다양한 객체를 하나의 인터페이스로 다룰 수 있다.
// 이 때 자식 클래스에서 부모 클래스의 메소드를 오버라이딩 한 경우
// 비록 부모 타입의 참조 변수를 사용하더라고, 실제 런타임 시에는 자식 클래스의 메소드가 호출된다.
// 이러한 동작은 자바의 동적바인딩에 의해 이루어지며 이것이 바로 다형성과 형변환의 관계이다.

/* ㄴ 형변환 사용 시 주의할 점은 무엇인가? */
// 형변환은 상속 또는 인터페이스 구현 관계가 있는 타입들 사이에서만 가능하다.
// 특히, down-casting의 경우 부모 타입의 참조 변수가 실제로 자식 객체를 참조하고 있어야만 가능하다.
// 그렇지 않을 경우에는 'ClassCastException'이 발생한다.
// 이를 방지하는 방법으로 instanceof 연산자를 사용함으로써 타입을 확인한 수 형변환을 수행하는 것이 안전하다.
// 또한 너무 많은 다운캐스팅은 코드의 안정성과 가독성을 해칠 수 있다.
// 그러므로 가능하다면 오버라이딩과 다형성을 적극 활용하는 구조가 바람직하다.

/* 추상클래스란? */
// 추상클래스란 하나 이상의 추상 메소드를 포함하는 클래스를 말한다.
// 여기서 추상 메소드란 구현체 부분 없이 메소드의 선언부만 존재하는 불완전한 메소드를 말한다.
// 추상 클래스는 스스로 인스턴스를 생성할 수 없으며 이를 상속받은 하위 클래스에서 추상 메소드를 모두 구현해야 인스턴스를 생성할 수 있다.
// 주로 상속을 통해 공통적인 속성과 기능을 상위 클래스에 정의하고, 하위 클래스에서 더 구체적인 동작을 구현하도록 강제하는 데 사용된다.
// 이런 구조를 통해 객체 지향 프로그래밍의 템플릿 역할을 수행하게 된다.
// 또한, 추상 클래스에서 작성한 메소드를 호출하더라도 실제 실행 되는 것은 하위 클래스에서 오버라이딩한 메소드로,
// 다형성이 적용되어 동적 바인딩에 의한 다양한 응답을 할 수 있다.
// 또한 추상 클래스를 상속받아 구현할 때는 extends 키워드를 사용하며 단일 상속만 지원한다.

/* 추상 클래스 특징 */
// 추상 클래스는 추상 메소드 뿐만 아니라 일반 메소드와 필드도 가질 수 있다.
// 추상 클래스를 상속받은 모든 하위의 일반 클래스들은 추상 메소드를 반드시 오버라이딩 해야한다.
// 단 추상 클래스를 다른 추상 클래스가 상속받을 경우에는 오버라이딩을 생략할 수 있다.
// 기본 생성자를 정의할 순 있지만 자체적으로 인스턴스를 생성할 수 없고 하위 클래스가 상속하여 구현한 후에만 인스턴스화가 가능하다.
// 추상 클래스 정의할 때 클래스 선언부에 abstract 키워드를 사용해야 한다.

/* 추사 클래스 사용하는 이유 */
// 추상 클래스는 스스로 인스턴스를 생성하지 못하지만 다형성 적용을 위해 부모 타입 역할은 할 수 있다.
// 추상 메소드를 포함한 추상 클래스는 추상 메소드를 통해 자식 클래스에 오버라이딩에 대한 강제성을 부여할 수 있다.
// 이는 필수 기능을 정의해 일관된 인터페이스(공통된 기능)를 제공함에 있어 도움이 된다.

/* 인터페이스란? */
// 인터페이스는 클래스와 유사한 구조를 가지지만, 추상 메소드와 상수 필드만 정의할 수 있는 일종의 설계 도구이다.
// 자바에서 인터페이스는 다형성 구현, 기능의 강제 그리고 다중 상속의 보완을 위해 사용된다.
// 인터페이스는 기본적으로 모든 메소드가 public abstract이며, 모든 필드는 public static final로 간주된다.
// 따라서 메소드를 오버라이딩할 때는 반드시 public 접근 제한자를 사용해야한다.
// 인터페이스는 구현부가 없는 추상 메소드를 가질 수 있지만 Java8 부터는 default 키워드를 사용하여 구현부가 있는 인스턴스 메소드를 가질 수 있다.
// 단 여기서 default는 접근 제한자가 아닌 기능을 가진 키워드이다.
// 또한 static 키워드를 사용하면 정적 메소드도 구현 가능하다.
// 인터페이스는 생성자를 가질 수 없고 자체적으로 인스턴스를 생성할 수 없다.
// 또한 인터페이스는 다중 상속이 가능하며 implements 키워드를 통해 인터페이스를 구현하는데 하나의 클래스가 여러 인터페이스를 동시에 구현할 수 있다.
// 이를 통해 자바의 단일 상속의 한계를 보완할 수 있다.
// 클래스가 다른 클래스를 상속받고 인터페이스도 구현하는 경우에는 클래스 선언부에 extends를 먼저 쓰고 implements를 사용해야한다.
// 단, static 메소드와 오버라이딩이 불가하지만 default 메소드는 구현 클래스에서 오버라이딩이 가능하다.

/* 인터페이스 사용하는 이유 */
// 인터페이스는 공유를 목적으로 하는 상수를 기반으로 모든 기능을 공통화해서 강제성을 부여할 목적으로 만들어졌다.
// 또한 자바의 단일 상속이라는 단점을 극복하기 위해 사용되기도 하며
// 모든 클래스는 하나의 부모 클래스 외에도 여러 개의 인터페이스를 구현할 수 있다.

/* 추상클래스와 인터페이스 공통점과 차이점 */
// 구분                                 추상 클래스                인터페이스
// 상속 가능 범위                        단일 상속                  다중 상속
// 키워드                               extends 사용              implements 사용
// 추상 메소드 갯수                      abstract 메소드 0개 이상    모든 메소드는 abstract
// abstract 키워드 명시                  명시적 사용                묵시적으로 abstract
// 자체 인스턴스 생성                     불가                      불가
// 다형성 적용 시 상위 타입 활용 가능성     가능                       가능