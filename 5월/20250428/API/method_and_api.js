/* Method */

/* static 메소드와 non-static 메소드의 차이를 설명하시오. */
// static 메소드는 클래스에 속하먀 인스턴스 생성 없이 호출할 수 있는 메소드이다.
// 반면 non-static 메소드는 객체 인스턴스에 속하여 객체를 생성해야 호출할 수 있다.
// 또한 static 메소드는 클래스명으로 호출하며 인스턴스 변수를 사용할 수 없고(인스턴스 변수에 접근할 수 없고,) 
// 디형성을 지원하지 않기 때문에 오버라이딩이 불가능하다.
// non-static 메소드는 객체를 통해 호출하며 인스턴스 변수에 접근 가능하고, 다형성을 지원하여
// 하쉬 클래스에서 오버라이딩이 가능하다.

/* static 멤버와 메소드의 활용 및 주의점을 설명하시오. */
// static 키워드는 모든 인스턴스가 공유하는 클래스 변수나 메소드를 정의할 때 사용된다.
// 예를 들어 유틸리티 메소드나 공용 데이터 저장용으로 자주 활용된다.
// 하지만 static 멤버는 프로그램 시작 시 메모리에 로딩되어 종료 시까지 유지되므로, 과도하게 사용하면
// 메모리 낭비나 관리의 어려움을 초래할 수 있다.
// 또한 객체 지향의 핵심 개념인 캡슐화와 다형성의 장점을 희생할 수 있기 대문에 필요한 경우에만 신중하게 사용하는 것이 중요하다.

/* ++) */
// 인스턴스 변수/메소드
// 객체가 생성될 때 마다 메모리에 새로 할당되는 멤버
// 객체가 있어야만 사용할 수 있다.
// static 메소드/변수
// 클래스가 처음 로딩될 때 메모리에 올라가며, 객체 생성 없이 사용된다.
// 클래스명.메소드명()으로 사용됨.
// 왜 static 메소드에서 인스턴스 멤버에 직접 접근할 수 없을까?
// static 메소드는 클래스 로딩 시점에 메모리에 올라가기 때문에, 아직 객체가 존재하지 않을 수 있다.
// 객체가 없으면 this.도 없고 인스턴스 변수나 메소드도 사용할 수 없다.

/* public class Person {
    String name = "홍길동"; // 인스턴스 변수

    public static void printName() {
        System.out.println(name); // 컴파일 에러! 인스턴스 변수를 직접 사용할 수 없음
    }
}; */

//위 코드에서 printName()은 static 메소드이기 때문에 name 이라는 인스턴스 변수에 직접 접근할 수 없다.
// 객체가 존재하지 않기 때문에.
// 어떻게 접근할 수 있나?
// 객체를 먼저 생성한 후에 그 객체를 통해 접근하면 문제 없다.

/* public class Person {
    String name = "홍길동";

    public static void printName() {
        Person p = new Person(); // 객체 생성
        System.out.println(p.name); // 이제 접근 가능
    }
};
 */

/* 객체지향언어의 핵심 개념 설명 - 캡슐화, 다형성 등등 */